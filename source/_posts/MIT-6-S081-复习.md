---
title: MIT 6.S081 复习
date: 2024-06-25 19:40:55
categories:
- work
-
tags:
- 课程笔记
- OS
- interview
---


<!-- more -->

参考
[某课程笔记](http://xv6.dgs.zone/)
[课程翻译](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081)

## 操作系统接口

### 进程和内存

> 当我们在shell中运行某个指令时，shell通常会创建一个新的进程来执行，即fork一个子进程，然后在子进程中调用`exec`来执行指令

#### fork调用
进程可以使用`fork`复制创建一个新进程，其内存内容与父进程完全一致（严格来说，父进程只是C程序被编译之后存在内存中的指令，因此是可以被100%复制的）
fork函数在父进程中返回子进程的PID，在子进程中返回0
```c
int pid = fork();
if(pid > 0) {
    printf("parent: child=%d\n", pid);
    // 等待直到任一子进程结束，返回pid
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if(pid == 0) {
    printf("child: exiting\n");
    // 退出，并返回状态码0 （一般0表正常，1表异常）
    exit(0);
} else {
    printf("fork error\n");
}
```
在fork函数执行时，父子进程的内存内容完全相同，但由于身份的不同后续可能执行不同的代码

#### exec调用
使用`exec`从文件系统中找到指定的可执行文件，将当前进程的内存内容替换为新的可执行文件的内容
`exec`通常不会返回，毕竟`exec`会完全替换当前进程的内存，除非执行错误（比如找不到该文件）
```c
char* argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
// exec认为第一个参数是程序名并忽略，所以此处的输出只有hello
// argv[2] = 0 标志了数组的结尾。值为0的指针对C来说表示结束
exec("/bin/echo", argv);
// 因此这里可以直接print error，因为exec成功的话就不会再执行后面代码
printf("exec error\n");
```

###  I/O和文件描述符

文件描述符（file descriptor）是一个小整数，用于表示进程可以读或写的对象，如文件、目录、设备、管道等。这种方式将文件、管道、设备之间的差异抽象出来，使他们看起来都像字节流

xv6内核使用文件描述符作为每个进程表的索引。每个进程都有一个从0开始的文件描述符表，每个表项指向一个“文件”，按照惯例，进程的文件描述符0，1，2分别指向标准输入、标准输出和标准错误

下面是一个进程使用系统调用`read`和`write`将数据从标准输入复制到标准输出的过程，如果失败，将错误信息写到标准错误：
```c
char buf[512];
int n;
for (;;) {
    // read 从fd0（标准输入）读取数据到buf中，并返回读取的字节数
    n = read(0, buf, sizeof buf);
    // read从fd0中读数据，每个文件会自带一个文件偏移量，记录上次读取的位置，并从该位置往下读
    // 也就是说，如果标准输入只给了512字节，那从第二个循环开始，n将为0，代表读取完成
    if (n == 0)
        break;
    if (n < 0) {
        // 在fd2（标准错误）中输出错误信息
        fprintf(2, "read error\n");
        exit(1);
    }
    // write 将buf中长度为n的数据写入文fd1（标准输出），并返回写入的字节数
    if (write(1, buf, n) != n) {
        fprintf(2, "write error\n");
        exit(1);
    }
}
```
这其实也是一个简单的cat程序，从标准输入读取数据，然后写到标准输出

系统调用`close`会释放一个fd，使其可被重用。在新分配fd时，总会分配当前进程中标号最小的未使用描述符

`fork`恢复至父进程的文件描述符表和内存，因此父子进程在开始拥有完全相同的打开文件。下面时利用fork进行I/O重定向的例子：
```c
char* argv[2];
argv[0] = "cat";
argv[1] = 0;
if (fork() == 0) {
    close(0);
    // 子进程关闭fd0之后，open保证新打开的input.txt分配最小的可用fd，也就是0
    // 即子进程将input.txt重定向为其标准输入
    open("input.txt", O_RDONLY);
    // cat会读取fd0的内容并输出到fd1，即读input.txt的内容并输出到标准输出
    exec("cat", argv);
}
```

需要注意的是，`fork`虽然会复制文件描述符表，并且这个表在之后不会共享，但是每个基础文件偏移量是共享的：
```c
if (fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
```
这段代码会输出`hello world`，因为子进程和父进程共享文件偏移量，所以子进程写完`hello`之后，标准输出（视为基础文件）的文件偏移量也会被移动到`hello`之后，所以父进程接着写`world`，而不是从头开始写

> 文件偏移量与文件描述符绑定，而不是文件本身

`dup` 系统调用会复制一个现有的文件描述符，返回一个新的文件描述符，指向同一个文件。和`fork`一样，`dup`出来的fd也和原来的fd共享偏移量（可以理解成引用）
```c
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

### 管道

管道是一对用于读和写的缓冲区，用于进程间通信。

如果没有可用数据，对于管道读操作会进入等待，直到有新数据写入，或者所有指向管道写的fd都被关闭

```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
// 创建管道，p[0]记录从管道读fd，p[1]记录从管道写fd
pipe(p);
if (fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    // 子进程将fd0指向管道读取端，并执行wc
    exec("/bin/wc", argv);
} else {
    close(p[0]);
    // 父进程将数据写入管道写入端
    write(p[1], "hello world\n", 12);
    // 这里关闭管道写入端，否则子进程的wc会一直等待
    close(p[1]);
}
```

## 操作系统架构——xv6
操作系统必须满足的是三个要求：多路复用、隔离、交互

### 抽象系统资源
操作系统需要协调多个应用程序的运行，比起每个应用程序直接操作硬件的同时还需要互相协调硬件使用时间，操作系统提供了一种抽象的硬件接口，将资源抽象为服务，实现不同应用之间的隔离

### 系统权限分层
RISC-V为CPU提供了三种CPU执行指令的模式：机器模式、管理模式（管态）、用户模式（目态）

CPU在机器模式下启动，执行少量代码完成初始化配置，然后切换管态，将控制权交给操作系统。操作系统在管态下运行，可以访问所有硬件资源，包括内存、I/O设备、时钟等。用户程序在目态下运行，只能访问有限的硬件资源，不能直接访问内存、I/O设备等，必须通过系统调用来访问

### 内核组织
一个关键问题是判断操作系统的哪些部分需要在管态运行，哪些部分需要在目态运行。

宏内核：整个操作系统都驻留在内核，所有系统调用的实现都以管态运行
缺点在于，OS不同部分的接口通常很复杂，内核难以维护，同时出错可能性较大

微内核：只有少量的核心功能驻留在内核，其他功能以用户态进程的形式运行。
比如说，微内核的文件系统作为用户级进程运行（被称为server），进程通过消息传递内核转发来调用文件系统服务。这样做的好处是，内核的代码量减少，内核更加稳定，同时用户态进程的代码可以更容易地被替换、升级，但坏处是一次交互可能需要多次目态/管态的跳转，影响性能；同时，将os的功能隔离开将更难实现内存共享

和大多数类Unix一样，xv6使用宏内核设计，尽管他的内核比很多微内核还要小

### xv6进程概述
xv6以进程为单位做隔离。这种抽象可以防止进程破坏或监视其他进程，或者破坏内核。

xv6使用由硬件实现的页表来为每个进程提供自己的地址空间，这样每个进程都有自己的专用空间。虚拟地址将每个进程所使用的空间与其他进程隔离开来。


## 页表

页表是OS为每个进程提供私有地址空间和内存的机制。

### 分页硬件
将虚拟地址映射到物理地址的硬件。每个进程都有一个自己的页表，并存储在物理内存中，这个页表的物理地址由内核保存。

当某个进程上CPU后，某个名为SATP的寄存器会装入该进程页表的物理地址。随后内存管理单元（MMU）根据地址找到该进程的页表，开始该进程虚拟内存到物理内存的映射

xv6基于Sv39 RISC-V，只是用64位虚拟地址中的低39位。页表硬件利用这39位找到一个56位的物理地址
![alt text](image1.png)

页表在逻辑上是一个由 $2^{27}$ 个页表条目（Page Table Entries）组成的数组，每个页表条目对应一个 $2^{12}$ 大小的页框，每个PTE包含一个44位的物理页号（Physical Page Number）和一些标志位，如可读、可写、可执行等

> 在上述系统中，虚拟内存空间大小为39位，而物理内存空间大小为56位，但并不是说物理内存空间一定会大于虚拟内存空间

分页硬件利用虚拟地址中的27位索引PTE，找到物理页框号，在结合虚拟地址的低12位偏移量，找到最终的物理地址

对于多级页表来说，仅仅是将PTE的物理页号替换为下一级页表的逻辑页号，然后再次索引，直到找到最终的物理页号而已，具体的原理和标志位含义等不再赘述

### 内核地址空间
xv6为每个进程维护一个页表，用来描述每个进程的用户地址空间，此外，还需要维护一个单独描述内核地址空间的页表

内核配置其地址空间的布局，以允许自己用虚拟地址访问物理内存和各种硬件资源
![alt text](image2.png)

这一部分结构大多由硬件设计者决定，当主板上电之后，主板做的第一件事就是运行存储在0x1000，即boot ROM中的代码，随后会从地址0x8000000000开始运行，启动操作系统。设计者规定，当完成了虚拟到物理地址的映射后，得到的地址如果大于0x8000000000，那么这个地址就是内核地址，走向物理内存；如果小于，就走向不同的I/O设备

进入系统后，首先需要配置内核使用的虚拟地址空间，也就是左图的地址分布，为了尽可能简单易懂，xv6的内核地址空间大部分与物理地址相等。

注意上图中有一部分page在虚拟内存的位置很靠后，如kernel stack，此外，两个Kstack后面都跟随了一个未被映射到物理内存的Guard Page。为了防止栈溢出，Guard Page的PTE中，其flags中的valid标志位会保持为空，这样当发生栈溢出时，MMU在访问溢出地址的PTE时会发现其valid位为空，从而触发异常，内核可以处理这个异常，而不是让程序继续执行。这样设置的同时还节省了物理内存

尽管kernel stack在Kernel data中被重复映射了一次，在实际使用Kstack时还是使用上面的这部分地址，因为由Guard page更加安全

实验还没看，先笼统回顾一遍吧

## 陷阱和系统调用
有三类事件会导致CPU搁置当前普通指令的执行，并将控制权转移给处理该事件的特殊代码：
1. 系统调用：用户程序执行`ecall`来要求内核执行某行动时
2. 异常：指令（用户或内核都可能）做了一些非法的事情
3. 设备中断：某设备向系统发出某种信号，表明它需要被处理

这三类被统称为trap，通常情况下，我们希望trap是透明的，正在cpu的代码只需要稍后恢复，而意识不到发生了任何特殊的事情，一般来说，处理顺序为：
trap强制将cpu控制权转移到内核-->内核保存寄存器和其他状态，以便稍后恢复-->内核执行适当的trap处理程序-->内核之前保存的状态


## 中断和设备驱动

